using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace TestAlg2
{
    public class Program
    {
        static void Main(string[] args)
        {
            Program pro = new Program();
            pro.test();

            //int n = int.Parse(Console.ReadLine());
            //string[] arr_temp = Console.ReadLine().Split(' ');
            //int[] arr = Array.ConvertAll(arr_temp, Int32.Parse);
            //Console.WriteLine(Sum(arr));


            //string[] tokens_a0 = Console.ReadLine().Split(' ');

            //int a0 = System.Convert.ToInt32(tokens_a0[0]);
            //int a1 = System.Convert.ToInt32(tokens_a0[1]);
            //int a2 = System.Convert.ToInt32(tokens_a0[2]);
            //string[] tokens_b0 = Console.ReadLine().Split(' ');
            //int b0 = System.Convert.ToInt32(tokens_b0[0]);
            //int b1 = System.Convert.ToInt32(tokens_b0[1]);
            //int b2 = System.Convert.ToInt32(tokens_b0[2]);
            //CountPoint(new int[] { a0,a1,a2}, new int[] {b0, b1, b2 });

            //string s = Console.ReadLine();
            //countCamel(s);

            CountForLongest("a");
            CountForLongest("acaca");
            CountForLongest("abab");
            CountForLongest("abaa");
            CountForLongest("abaab");
            CountForLongest("aaab");
            CountForLongest("aaabccc");

            CountForLongest("aaa");
            CountForLongest("czoczkotespkfjnkbgpfnmtgqhorrzdppcebyybhlcsplqcqogqaszjgorlsrppinhgpaweydclepyftywafupqsjrbkqakpygolyyfksvqetrfzrcmatlicxtcxulwgvlnslazpfpoqrgssfcrfvwbtxaagjfahcgxbjlltfpprpcjyivxu");
            CountForLongest("beabeefeab");
            int len = System.Convert.ToInt32(Console.ReadLine());
            string s = Console.ReadLine();
            if (len <= s.Length)
            {
                s = s.Substring(0, len);
                CountForLongest(s);
            }
            else
                Console.WriteLine("0");
            
            Console.ReadLine();
        }

         
        static void CountForLongest(string s)
        {
            HashSet<char> hs = new HashSet<char>();
            foreach(var c in s)
            {
                hs.Add(c);
            }
            char[] listC = hs.ToArray();
            int maxLength = 0;
            for(int i = 0;i < listC.Length - 1; i ++)
            {
                for (int j = i + 1; j < listC.Length ; j++)
                {
                    int len = KeepTwo(s,s[i],s[j]);
                    if (len > maxLength) maxLength = len;
                }
            }
            Console.WriteLine(maxLength);
        }
        static int KeepTwo(string s,char c1, char c2)
        {
            int pre = -1;
            int len = 0;
            for(int i = 0; i < s.Length; i++)
            {
                if(s[i] == c1 || s[i] == c2)
                {
                    len++;
                    if (pre >= 0 && s[i] == s[pre])
                    {
                        return 0;
                    }
                    pre = i;
                }
            }
            return len;
        }

        static void countCamel(string s)
        {
            int count = 1;
            if (s == "") count = 0;
            
            for(int i = 1; i < s.Length; i ++)
            {
                if (char.IsUpper(s[i]))
                {
                    count++;
                }
            }
            Console.WriteLine(count);

        }

        static void CountPoint(int []a,int []b)
        {
            int[] result = new int[2];
            for(int i = 0;i < a.Length; i++)
            {
                if(a[i] > b[i])
                {
                    result[0]++;
                }else if (a[i] < b[i])
                {
                    result[1]++;
                }
            }
            Console.WriteLine(result[0] + " " + result[1]);
        } 

        static long Sum(int []arr)
        {
            long r = 0;
            foreach(var i in arr)
            {
                r += i;
            }
            return r;
        }
        void test()
        {
            int ri = MaxSubArray(new int[] { -4, 5, 9, -3, 5 });

            ri = Reverse(945);
            ri = Reverse(-1945);
            ri = Reverse(1534236469);

            var arr = Intersection(new int[] { 1, 3, 4, 6, 6, 7, 8 }, new int[] { 1, 1, 6, 6, 9 });

            arr = Intersection(new int[] { 1, 3, 4, 6, 6, 7, 8,12 }, new int[] { 1, 1, 6, 6, 9,10,11,12 });

            arr = Intersection(new int[] { 1, 2,2,1 }, new int[] {2,2 });

            arr = Intersection(new int[] { 2,1 }, new int[] { 1,2 });

            var intervals = Merge(new Interval[] { new Interval(1,3) , new Interval(2,6) , new Interval(8,10) 
                , new Interval(15,18) });

            intervals = Merge(new Interval[] { new Interval(1,4) , new Interval(2,9) , new Interval(8,10)
                , new Interval(15,18) });

            intervals = Merge(new Interval[] { new Interval(1,1) , new Interval(1,1) , new Interval(1,1) });

            intervals = Merge(new Interval[] { new Interval(1, 1), new Interval(1, 1), new Interval(1, 9) });

            intervals = Merge(new Interval[] { new Interval(1, 1), new Interval(0, 4) });

            RandomListNode n1 = new RandomListNode(1);
            RandomListNode n2 = new RandomListNode(2);
            RandomListNode n3 = new RandomListNode(3);
            RandomListNode n4 = new RandomListNode(4);
            n1.next = n2; n2.next = n3; n3.next = n4;
            n1.random = n4; n3.random = n4;
            var newN = CopyRandomList(n1);

            n1 = new RandomListNode(1);
            n1.random = n1;
            newN = CopyRandomList(n1);

            HashSet<int> hsT = new HashSet<int>();
            hsT.Add(1);
            hsT.Add(1);

            int minimizedN = SplitArray(new int[] { 1, 9, 7, 4, 5, 7, 8 },2);
            minimizedN = SplitArray(new int[] { 7, 2, 5, 10, 8 }, 2);

            minimizedN = SplitArray(new int[] { 7, 2, 5 }, 3);
            minimizedN = SplitArray(new int[] { 7, 2, 5 }, 2);

            minimizedN = SplitArray(new int[] { 7, 2, 5 }, 1);
            minimizedN = SplitArray(new int[] { 7, 2, 5 }, 1);

            int[,] people = new int[,] { { 7, 0 }, { 4, 4 }, { 7, 1 }, { 5, 0 }, { 6, 1 }, { 5, 2 } };
            var peopleR = ReconstructQueue(people);

            people = new int[,] { };
            peopleR = ReconstructQueue(people);

            people = new int[,] { { 701148, 12 }, { 654124, 204 }, { 57460, 633 }, { 276451, 543 }, { 512650, 415 }, { 113606, 407 }, { 921752, 24 }, { 40215, 0 }, { 817357, 25 }, { 445510, 517 }, { 625727, 250 }, { 218704, 143 }, { 589791, 261 }, { 662559, 35 }, { 719074, 150 }, { 818916, 144 }, { 252777, 737 }, { 641365, 299 }, { 351186, 222 }, { 198656, 619 }, { 574011, 237 }, { 126997, 467 }, { 129559, 551 }, { 928191, 28 }, { 510076, 29 }, { 905917, 81 }, { 770330, 21 }, { 996683, 0 }, { 630775, 174 }, { 256391, 457 }, { 739003, 32 }, { 783631, 122 }, { 707300, 29 }, { 609339, 217 }, { 440610, 464 }, { 878673, 71 }, { 122590, 472 }, { 669937, 194 }, { 587660, 320 }, { 171884, 126 }, { 523541, 215 }, { 548121, 78 }, { 523763, 377 }, { 486034, 207 }, { 234646, 596 }, { 852888, 13 }, { 656624, 155 }, { 722958, 216 }, { 847845, 38 }, { 20567, 444 }, { 250886, 446 }, { 680168, 272 }, { 152978, 555 }, { 570878, 388 }, { 682414, 93 }, { 245482, 21 }, { 615166, 141 }, { 740800, 35 }, { 517723, 263 }, { 975978, 5 }, { 605987, 277 }, { 467455, 30 }, { 271361, 92 }, { 642157, 1 }, { 808010, 165 }, { 72486, 749 }, { 686896, 211 }, { 833428, 91 }, { 386300, 125 }, { 966149, 3 }, { 977467, 13 }, { 527885, 439 }, { 435518, 283 }, { 197734, 307 }, { 168837, 629 }, { 496585, 11 }, { 741933, 132 }, { 126381, 545 }, { 386450, 152 }, { 705979, 16 }, { 923556, 6 }, { 463645, 494 }, { 95042, 491 }, { 720613, 107 }, { 702941, 247 }, { 318908, 30 }, { 91749, 322 }, { 479279, 208 }, { 900994, 74 }, { 979245, 2 }, { 440074, 466 }, { 635872, 270 }, { 220734, 437 }, { 12585, 53 }, { 481700, 290 }, { 110799, 364 }, { 854062, 109 }, { 653156, 203 }, { 267672, 87 }, { 536258, 54 }, { 918245, 24 }, { 580957, 131 }, { 274956, 277 }, { 467276, 371 }, { 23856, 809 }, { 60707, 859 }, { 44365, 315 }, { 911548, 80 }, { 243281, 752 }, { 277486, 47 }, { 868717, 113 }, { 96382, 389 }, { 850063, 149 }, { 427397, 49 }, { 608414, 276 }, { 333506, 581 }, { 131385, 839 }, { 761153, 121 }, { 380270, 73 }, { 814111, 102 }, { 245409, 357 }, { 257991, 295 }, { 231996, 333 }, { 126447, 442 }, { 68689, 887 }, { 730118, 172 }, { 901094, 47 }, { 807394, 104 }, { 443280, 435 }, { 939884, 56 }, { 948480, 6 }, { 201132, 581 }, { 490959, 476 }, { 759325, 150 }, { 949153, 0 }, { 549730, 320 }, { 171275, 803 }, { 428585, 67 }, { 2427, 708 }, { 743872, 130 }, { 358698, 164 }, { 965557, 5 }, { 326456, 308 }, { 229153, 334 }, { 397243, 468 }, { 353644, 458 }, { 215215, 597 }, { 37200, 860 }, { 910959, 21 }, { 24145, 370 }, { 882475, 0 }, { 961878, 22 }, { 267402, 506 }, { 13669, 652 }, { 687307, 53 }, { 425786, 544 }, { 256958, 334 }, { 481940, 366 }, { 523315, 429 }, { 978009, 10 }, { 252101, 718 }, { 922951, 46 }, { 985700, 4 }, { 745227, 209 }, { 350768, 508 }, { 545533, 178 }, { 5510, 822 }, { 113190, 291 }, { 910258, 37 }, { 100255, 638 }, { 530123, 348 }, { 89358, 461 }, { 66317, 59 }, { 418235, 106 }, { 404949, 392 }, { 353426, 648 }, { 772212, 15 }, { 316586, 375 }, { 520168, 59 }, { 323, 189 }, { 150462, 671 }, { 967877, 18 }, { 320526, 506 }, { 287828, 68 }, { 589888, 300 }, { 733465, 192 }, { 238230, 2 }, { 410471, 127 }, { 721063, 122 }, { 199531, 123 }, { 935226, 61 }, { 930142, 62 }, { 116330, 619 }, { 366596, 452 }, { 863593, 45 }, { 219986, 49 }, { 643493, 137 }, { 572463, 121 }, { 560116, 82 }, { 904018, 32 }, { 572589, 308 }, { 302120, 131 }, { 384862, 237 }, { 918121, 67 }, { 34551, 516 }, { 381894, 361 }, { 77773, 239 }, { 866557, 19 }, { 990546, 1 }, { 718055, 22 }, { 984537, 11 }, { 761568, 78 }, { 876699, 61 }, { 101489, 388 }, { 459253, 254 }, { 103241, 663 }, { 983296, 11 }, { 837655, 102 }, { 242671, 545 }, { 227241, 108 }, { 995154, 0 }, { 624583, 354 }, { 847918, 127 }, { 82060, 185 }, { 289094, 406 }, { 678003, 32 }, { 396914, 150 }, { 516336, 135 }, { 380177, 72 }, { 189497, 168 }, { 109644, 232 }, { 933213, 63 }, { 536221, 150 }, { 129085, 374 }, { 969100, 23 }, { 38936, 488 }, { 276617, 482 }, { 353187, 526 }, { 640587, 34 }, { 774509, 172 }, { 21008, 748 }, { 636989, 58 }, { 554739, 331 }, { 915709, 76 }, { 462918, 20 }, { 588849, 258 }, { 60319, 290 }, { 426865, 381 }, { 540592, 7 }, { 196228, 371 }, { 873446, 21 }, { 672155, 219 }, { 385755, 259 }, { 233683, 626 }, { 558365, 315 }, { 127597, 574 }, { 743364, 224 }, { 866408, 91 }, { 71710, 122 }, { 333297, 459 }, { 457669, 471 }, { 260053, 455 }, { 362972, 359 }, { 76169, 290 }, { 490591, 109 }, { 482206, 84 }, { 499321, 289 }, { 912843, 66 }, { 401777, 58 }, { 54525, 287 }, { 432192, 45 }, { 657817, 311 }, { 416757, 42 }, { 164681, 773 }, { 74537, 82 }, { 155988, 76 }, { 415507, 89 }, { 267971, 671 }, { 398210, 341 }, { 825559, 143 }, { 217497, 671 }, { 509202, 457 }, { 459131, 173 }, { 540075, 315 }, { 635625, 56 }, { 74602, 209 }, { 913700, 13 }, { 887329, 104 }, { 52464, 605 }, { 174721, 646 }, { 286845, 128 }, { 999278, 0 }, { 402303, 179 }, { 595622, 291 }, { 341616, 497 }, { 9120, 671 }, { 796504, 65 }, { 938993, 5 }, { 234555, 308 }, { 268023, 378 }, { 264227, 162 }, { 178849, 796 }, { 21091, 612 }, { 44317, 85 }, { 639282, 258 }, { 332566, 593 }, { 772932, 213 }, { 316701, 537 }, { 486058, 213 }, { 174069, 541 }, { 755603, 167 }, { 557051, 71 }, { 875316, 86 }, { 676782, 37 }, { 261749, 662 }, { 802050, 7 }, { 185994, 324 }, { 223415, 436 }, { 315115, 222 }, { 709673, 125 }, { 617059, 216 }, { 567578, 91 }, { 129205, 805 }, { 359939, 333 }, { 222218, 394 }, { 122032, 513 }, { 910310, 53 }, { 497565, 228 }, { 820758, 80 }, { 788160, 43 }, { 691975, 18 }, { 866545, 80 }, { 58261, 693 }, { 79145, 754 }, { 535013, 94 }, { 606753, 209 }, { 123840, 69 }, { 869818, 62 }, { 264839, 490 }, { 344685, 330 }, { 743016, 107 }, { 199088, 112 }, { 682669, 42 }, { 401305, 92 }, { 194684, 208 }, { 219419, 522 }, { 396429, 411 }, { 131424, 16 }, { 600469, 60 }, { 374883, 476 }, { 419494, 243 }, { 494010, 116 }, { 382704, 231 }, { 588723, 108 }, { 451979, 294 }, { 940087, 37 }, { 760957, 110 }, { 874969, 7 }, { 200077, 160 }, { 881759, 62 }, { 181851, 133 }, { 270347, 346 }, { 214779, 261 }, { 961679, 12 }, { 150254, 194 }, { 651134, 198 }, { 497247, 457 }, { 851584, 125 }, { 333907, 656 }, { 718810, 25 }, { 744725, 89 }, { 948415, 37 }, { 911191, 45 }, { 178726, 658 }, { 409675, 510 }, { 647241, 26 }, { 620727, 35 }, { 165449, 508 }, { 692770, 264 }, { 56055, 108 }, { 692819, 102 }, { 216246, 336 }, { 765827, 204 }, { 533461, 427 }, { 802056, 177 }, { 94909, 271 }, { 171054, 680 }, { 957687, 28 }, { 737835, 217 }, { 67764, 792 }, { 384829, 550 }, { 509317, 486 }, { 761353, 52 }, { 966692, 20 }, { 70392, 308 }, { 331834, 377 }, { 102393, 335 }, { 813760, 121 }, { 955260, 29 }, { 821533, 112 }, { 186431, 354 }, { 40194, 650 }, { 831224, 84 }, { 165407, 43 }, { 944095, 16 }, { 110661, 414 }, { 229307, 411 }, { 691201, 245 }, { 949115, 43 }, { 122980, 546 }, { 409938, 215 }, { 710872, 82 }, { 461366, 164 }, { 354089, 232 }, { 875286, 49 }, { 829832, 5 }, { 594215, 23 }, { 973871, 8 }, { 683190, 46 }, { 459389, 397 }, { 375974, 59 }, { 286931, 452 }, { 617320, 216 }, { 47510, 549 }, { 848505, 73 }, { 564682, 58 }, { 245820, 215 }, { 524471, 188 }, { 612496, 181 }, { 694067, 189 }, { 88883, 775 }, { 342337, 494 }, { 182394, 419 }, { 508341, 45 }, { 924554, 13 }, { 333576, 316 }, { 681019, 134 }, { 592478, 190 }, { 205740, 696 }, { 485079, 338 }, { 387191, 560 }, { 55336, 676 }, { 636480, 136 }, { 847177, 4 }, { 170114, 573 }, { 388315, 340 }, { 786667, 203 }, { 748305, 136 }, { 900975, 19 }, { 812977, 175 }, { 434581, 174 }, { 385907, 502 }, { 789348, 65 }, { 515260, 321 }, { 167715, 275 }, { 639838, 8 }, { 875351, 116 }, { 215546, 241 }, { 502799, 412 }, { 160558, 374 }, { 52918, 257 }, { 56757, 607 }, { 204721, 583 }, { 890048, 29 }, { 947677, 32 }, { 48586, 29 }, { 440579, 118 }, { 334728, 458 }, { 814282, 76 }, { 842816, 93 }, { 333399, 437 }, { 521726, 415 }, { 376621, 377 }, { 603940, 215 }, { 722172, 5 }, { 418564, 138 }, { 396296, 323 }, { 251816, 212 }, { 665131, 55 }, { 41991, 289 }, { 764442, 66 }, { 846426, 153 }, { 445431, 116 }, { 465979, 26 }, { 571083, 12 }, { 941497, 16 }, { 967873, 3 }, { 173533, 272 }, { 114218, 595 }, { 865451, 18 }, { 296835, 570 }, { 386216, 12 }, { 334604, 472 }, { 505177, 288 }, { 139265, 814 }, { 108594, 372 }, { 674884, 206 }, { 155895, 50 }, { 654437, 125 }, { 864481, 1 }, { 571192, 11 }, { 972404, 11 }, { 187618, 440 }, { 58814, 184 }, { 793789, 107 }, { 940404, 56 }, { 164213, 317 }, { 497886, 468 }, { 437271, 551 }, { 968966, 12 }, { 593589, 263 }, { 782853, 111 }, { 335742, 590 }, { 348129, 189 }, { 940865, 42 }, { 861727, 94 }, { 148632, 797 }, { 381216, 380 }, { 399815, 53 }, { 263904, 160 }, { 417183, 223 }, { 175905, 445 }, { 39626, 459 }, { 775122, 187 }, { 477583, 396 }, { 586388, 263 }, { 762381, 170 }, { 625012, 218 }, { 583195, 78 }, { 62189, 774 }, { 880685, 35 }, { 347869, 249 }, { 211136, 86 }, { 177207, 135 }, { 610268, 66 }, { 934451, 44 }, { 509185, 463 }, { 509192, 244 }, { 488777, 155 }, { 504719, 342 }, { 221236, 543 }, { 999518, 0 }, { 817537, 92 }, { 672876, 213 }, { 827878, 22 }, { 415548, 490 }, { 822860, 31 }, { 970818, 8 }, { 990513, 5 }, { 167332, 752 }, { 51103, 764 }, { 702944, 98 }, { 544861, 56 }, { 995593, 1 }, { 728060, 148 }, { 979982, 9 }, { 299455, 515 }, { 147408, 142 }, { 194011, 66 }, { 220440, 66 }, { 170159, 224 }, { 458317, 507 }, { 533185, 281 }, { 14523, 571 }, { 262999, 257 }, { 356649, 126 }, { 199972, 748 }, { 448499, 397 }, { 305058, 344 }, { 925721, 36 }, { 854194, 106 }, { 22298, 450 }, { 944298, 26 }, { 233494, 536 }, { 312109, 313 }, { 413094, 130 }, { 464947, 488 }, { 94417, 364 }, { 417140, 188 }, { 823884, 104 }, { 885508, 21 }, { 666118, 144 }, { 883088, 21 }, { 297783, 263 }, { 405279, 136 }, { 768127, 221 }, { 615222, 138 }, { 983157, 6 }, { 146290, 173 }, { 235975, 423 }, { 988539, 0 }, { 456375, 105 }, { 353914, 152 }, { 101110, 621 }, { 966036, 25 }, { 182467, 317 }, { 369755, 27 }, { 688051, 289 }, { 148711, 151 }, { 559445, 398 }, { 709361, 167 }, { 972672, 19 }, { 609524, 313 }, { 272763, 581 }, { 26196, 800 }, { 888837, 12 }, { 441089, 232 }, { 938149, 38 }, { 721820, 106 }, { 851235, 10 }, { 928311, 13 }, { 268780, 336 }, { 667344, 262 }, { 546728, 205 }, { 953642, 7 }, { 784918, 9 }, { 396003, 45 }, { 535811, 30 }, { 412400, 52 }, { 334813, 386 }, { 295008, 446 }, { 413831, 520 }, { 810150, 154 }, { 142227, 308 }, { 746868, 94 }, { 980824, 2 }, { 744487, 148 }, { 876647, 12 }, { 69004, 618 }, { 573268, 259 }, { 321442, 213 }, { 495633, 198 }, { 342789, 144 }, { 412660, 495 }, { 900305, 46 }, { 176737, 242 }, { 894461, 82 }, { 49676, 495 }, { 189012, 633 }, { 363101, 62 }, { 232381, 469 }, { 177503, 412 }, { 321496, 578 }, { 191412, 352 }, { 714201, 24 }, { 64091, 28 }, { 701149, 257 }, { 244944, 453 }, { 93, 85 }, { 830304, 21 }, { 120896, 464 }, { 73870, 451 }, { 403529, 297 }, { 376263, 283 }, { 472633, 159 }, { 117155, 821 }, { 534070, 213 }, { 98165, 712 }, { 616614, 88 }, { 548211, 278 }, { 485445, 88 }, { 438799, 140 }, { 769586, 159 }, { 572483, 339 }, { 853295, 86 }, { 588474, 276 }, { 549294, 397 }, { 816220, 57 }, { 601070, 121 }, { 406847, 368 }, { 234660, 325 }, { 50707, 214 }, { 909246, 70 }, { 500843, 260 }, { 750073, 162 }, { 470380, 125 }, { 554328, 286 }, { 492800, 390 }, { 721459, 207 }, { 193837, 344 }, { 845388, 64 }, { 367423, 216 }, { 222095, 224 }, { 236872, 19 }, { 72699, 752 }, { 169347, 72 }, { 511485, 455 }, { 807882, 108 }, { 870496, 62 }, { 216446, 524 }, { 846053, 90 }, { 346276, 294 }, { 758826, 210 }, { 40584, 400 }, { 483778, 203 }, { 122523, 459 }, { 740287, 244 }, { 265238, 188 }, { 706541, 4 }, { 949563, 41 }, { 44746, 757 }, { 469168, 206 }, { 519640, 369 }, { 147070, 11 }, { 260595, 688 }, { 444267, 534 }, { 694223, 104 }, { 443037, 136 }, { 559189, 56 }, { 655112, 218 }, { 534697, 396 }, { 866429, 39 }, { 336066, 661 }, { 961688, 19 }, { 557142, 410 }, { 227022, 698 }, { 777364, 79 }, { 532091, 281 }, { 200474, 289 }, { 591026, 72 }, { 173797, 347 }, { 107681, 196 }, { 919533, 19 }, { 199257, 52 }, { 518078, 399 }, { 493080, 52 }, { 73764, 102 }, { 495096, 333 }, { 869145, 63 }, { 673369, 53 }, { 753219, 81 }, { 81555, 794 }, { 988922, 0 }, { 331354, 116 }, { 209802, 234 }, { 824791, 121 }, { 549, 532 }, { 238319, 312 }, { 101665, 144 }, { 142902, 839 }, { 816134, 69 }, { 262331, 638 }, { 16204, 300 }, { 838179, 27 }, { 319291, 289 }, { 595508, 264 }, { 524657, 69 }, { 725394, 241 }, { 91583, 85 }, { 220510, 379 }, { 697603, 219 }, { 445143, 375 }, { 859226, 133 }, { 46380, 922 }, { 289812, 409 }, { 706138, 228 }, { 792856, 137 }, { 691647, 15 }, { 64662, 171 }, { 509589, 327 }, { 36189, 41 }, { 243700, 499 }, { 322269, 106 }, { 153538, 585 }, { 828487, 54 }, { 198673, 532 }, { 443745, 277 }, { 920964, 11 }, { 500202, 175 }, { 376242, 19 }, { 738724, 33 }, { 562649, 155 }, { 817857, 105 }, { 947051, 39 }, { 622560, 141 }, { 503812, 316 }, { 23078, 162 }, { 892983, 35 }, { 822806, 6 }, { 248540, 140 }, { 555382, 334 }, { 319332, 202 }, { 204680, 784 }, { 146546, 563 }, { 587760, 68 }, { 659789, 112 }, { 96169, 441 }, { 355903, 338 }, { 137166, 622 }, { 875017, 109 }, { 186872, 2 }, { 671752, 120 }, { 793946, 158 }, { 760182, 133 }, { 942916, 33 }, { 150799, 273 }, { 511058, 136 }, { 138863, 623 }, { 661806, 215 }, { 786664, 192 }, { 547287, 279 }, { 643385, 40 }, { 818509, 53 }, { 887989, 26 }, { 103978, 360 }, { 138954, 220 }, { 206371, 318 }, { 586766, 286 }, { 344774, 452 }, { 986667, 5 }, { 799634, 160 }, { 302073, 325 }, { 411204, 52 }, { 684294, 152 }, { 986264, 11 }, { 266066, 100 }, { 472612, 165 }, { 832056, 70 }, { 353127, 318 }, { 428484, 26 }, { 144830, 748 }, { 925786, 67 }, { 848145, 128 }, { 898061, 80 }, { 47329, 222 }, { 761745, 2 }, { 190800, 349 }, { 210619, 555 }, { 321813, 203 }, { 787891, 88 }, { 957677, 31 }, { 726645, 158 }, { 34190, 93 }, { 757022, 170 }, { 863907, 85 }, { 548444, 192 }, { 357509, 89 }, { 3637, 960 }, { 482438, 161 }, { 715638, 49 }, { 757354, 115 }, { 708675, 212 }, { 439379, 69 }, { 875909, 88 }, { 162945, 376 }, { 329519, 92 }, { 732620, 153 }, { 711381, 185 }, { 695631, 245 }, { 549109, 221 }, { 707630, 268 }, { 527092, 147 }, { 313225, 356 }, { 308630, 661 }, { 818446, 23 }, { 796467, 156 }, { 520737, 219 }, { 610639, 139 }, { 434455, 199 }, { 457666, 319 }, { 711981, 210 }, { 61991, 919 }, { 662720, 313 }, { 873515, 100 }, { 556829, 329 }, { 327046, 298 }, { 376426, 115 }, { 768735, 181 }, { 605356, 86 }, { 541468, 366 }, { 933022, 9 }, { 215004, 576 }, { 644146, 93 }, { 548850, 174 }, { 655458, 5 }, { 566590, 260 }, { 147732, 169 }, { 561763, 96 }, { 339609, 349 }, { 479703, 114 }, { 163038, 22 }, { 90717, 350 }, { 735046, 98 }, { 582799, 111 }, { 447450, 45 }, { 346896, 381 }, { 630773, 49 }, { 295153, 581 }, { 342428, 501 }, { 524081, 424 }, { 354279, 148 }, { 385387, 157 }, { 845746, 93 }, { 893403, 38 }, { 253124, 356 }, { 669532, 83 }, { 619041, 188 }, { 443731, 263 }, { 166829, 668 }, { 750128, 87 }, { 913295, 13 }, { 577822, 1 }, { 774222, 72 }, { 628762, 62 }, { 596803, 109 }, { 796072, 15 }, { 263301, 41 }, { 882328, 101 }, { 413022, 565 }, { 626064, 254 }, { 936868, 40 }, { 552473, 131 }, { 599722, 273 }, { 772582, 71 }, { 475154, 505 }, { 854353, 113 }, { 545146, 442 }, { 186358, 668 }, { 499433, 231 }, { 487236, 353 }, { 255018, 58 }, { 265405, 522 }, { 868399, 91 }, { 339349, 412 }, { 17315, 348 }, { 395389, 402 }, { 80262, 183 }, { 561927, 125 }, { 87183, 260 }, { 880533, 34 }, { 117184, 77 }, { 1914, 568 }, { 291216, 34 }, { 677538, 88 }, { 727459, 34 }, { 875978, 29 }, { 438469, 467 }, { 635591, 92 }, { 643316, 245 }, { 346768, 601 }, { 354718, 417 }, { 676149, 80 }, { 651378, 16 }, { 629701, 225 }, { 626409, 15 }, { 572965, 335 }, { 528627, 322 }, { 196827, 233 }, { 109849, 439 }, { 333205, 634 }, { 157106, 159 }, { 358825, 95 }, { 414865, 518 }, { 635244, 226 }, { 861792, 136 }, { 310085, 118 }, { 753683, 206 }, { 809889, 175 }, { 162286, 587 }, { 643566, 3 }, { 947041, 27 }, { 613465, 183 }, { 244623, 647 }, { 544207, 188 }, { 73828, 244 }, { 127303, 98 }, { 987193, 9 }, { 700272, 88 }, { 229189, 646 }, { 780300, 41 }, { 658435, 186 }, { 437215, 442 }, { 715005, 197 }, { 463558, 132 }, { 921995, 60 }, { 894828, 13 }, { 180921, 593 }, { 117792, 612 }, { 831590, 136 }, { 612604, 159 }, { 114641, 801 }, { 404619, 270 }, { 161534, 705 }, { 907526, 54 }, { 555366, 61 }, { 359574, 560 }, { 955771, 19 }, { 17223, 454 }, { 566101, 308 }, { 293255, 567 }, { 719330, 105 }, { 723111, 181 }, { 868837, 33 }, { 453810, 38 }, { 962564, 3 }, { 770387, 189 }, { 486128, 126 }, { 534604, 318 }, { 420696, 55 }, { 359264, 571 } };

            peopleR = ReconstructQueue(people);

            people = new int[,]{ { 57115,708},{ 344019,648},{ 220851,219},{ 774787,106},{ 316153,98},{ 168133,229},{ 43914,862},{ 723562,218},{ 701812,53},{ 371392,107},{ 782692,156},{ 585923,94},{ 745702,191},{ 984211,3},{ 775096,165},{ 785758,186},{ 481106,392},{ 716492,210},{ 294815,709},{ 133596,796},{ 777750,105},{ 615209,385},{ 300213,166},{ 227118,431},{ 274789,104},{ 248130,651},{ 340564,590},{ 9206,136},{ 321869,186},{ 324065,673},{ 238867,161},{ 292890,226},{ 764828,189},{ 969589,24},{ 448452,534},{ 695316,224},{ 130985,274},{ 365403,391},{ 492747,341},{ 141133,94},{ 285513,387},{ 959576,15},{ 211014,399},{ 145669,221},{ 920561,75},{ 190922,405},{ 886271,104},{ 345703,326},{ 898603,87},{ 995797,1},{ 307750,61},{ 36936,531},{ 152336,137},{ 31790,921},{ 838779,76},{ 753124,52},{ 754977,231},{ 251201,92},{ 412412,227},{ 48529,704},{ 430901,106},{ 620548,347},{ 175890,524},{ 438492,377},{ 462879,232},{ 293807,55},{ 996816,1},{ 902255,52},{ 941457,63},{ 427010,73},{ 181562,275},{ 924464,14},{ 597513,134},{ 166264,216},{ 959864,41},{ 606442,66},{ 907370,22},{ 127156,85},{ 894604,89},{ 524594,109},{ 507888,487},{ 275456,610},{ 815277,174},{ 48267,691},{ 395546,307},{ 826693,97},{ 4310,353},{ 165915,562},{ 232734,66},{ 736078,216},{ 935666,17},{ 730970,216},{ 278851,263},{ 76445,537},{ 934396,3},{ 989935,7},{ 892045,53},{ 78002,297},{ 371690,533},{ 590180,186},{ 912989,25},{ 406667,406},{ 397820,602},{ 37062,656},{ 448215,279},{ 917358,23},{ 378125,23},{ 622720,218},{ 50197,561},{ 287125,543},{ 438180,459},{ 857769,6},{ 154508,539},{ 425672,26},{ 627894,45},{ 595520,233},{ 946245,21},{ 343238,452},{ 63073,267},{ 792036,25},{ 397309,161},{ 256187,677},{ 577091,45},{ 36437,710},{ 111994,493},{ 541876,151},{ 130968,69},{ 334002,621},{ 582735,188},{ 961297,38},{ 818961,141},{ 594697,40},{ 980228,8},{ 609498,188},{ 506645,483},{ 417405,367},{ 714440,176},{ 904491,79},{ 988628,9},{ 287504,580},{ 778181,152},{ 536681,317},{ 287458,302},{ 697565,26},{ 368523,350},{ 901145,85},{ 948891,15},{ 501661,86},{ 868189,52},{ 653408,46},{ 855938,77},{ 343750,359},{ 778175,68},{ 402720,366},{ 957539,9},{ 685205,137},{ 833335,166},{ 641217,11},{ 415147,45},{ 372052,530},{ 15057,763},{ 334697,209},{ 766780,188},{ 563574,224},{ 325578,587},{ 621233,377},{ 781810,148},{ 801442,124},{ 668681,77},{ 555898,12},{ 173136,83},{ 378250,475},{ 288515,690},{ 625524,305},{ 733273,276},{ 664164,333},{ 495632,85},{ 772020,211},{ 50531,879},{ 701519,144},{ 332313,215},{ 625677,302},{ 540655,175},{ 181862,467},{ 220377,208},{ 109445,422},{ 31600,578},{ 137703,370},{ 839760,84},{ 329709,527},{ 37138,735},{ 467798,470},{ 549887,337},{ 302457,472},{ 726037,17},{ 14148,982},{ 413388,576},{ 917313,4},{ 165198,583},{ 642235,70},{ 51584,179},{ 373997,569},{ 597939,365},{ 915125,62},{ 407918,583},{ 944539,2},{ 338524,607},{ 974323,1},{ 375525,588},{ 827124,142},{ 838558,42},{ 71892,841},{ 566995,310},{ 806931,37},{ 683085,294},{ 798340,195},{ 224472,772},{ 10165,105},{ 422147,500},{ 850244,68},{ 316929,185},{ 569051,116},{ 649746,88},{ 969377,26},{ 138496,88},{ 926143,41},{ 217741,525},{ 620421,148},{ 949884,41},{ 24020,440},{ 974391,3},{ 821123,134},{ 511965,5},{ 70330,464},{ 257917,261},{ 217972,529},{ 711703,72},{ 376042,330},{ 266229,40},{ 158967,495},{ 81858,688},{ 719259,145},{ 514934,93},{ 27157,790},{ 198105,241},{ 801153,198},{ 855284,13},{ 423094,493},{ 934444,12},{ 326657,322},{ 625567,314},{ 59543,83},{ 213948,101},{ 162325,291},{ 650032,128},{ 848896,35},{ 663325,162},{ 603198,73},{ 591804,149},{ 109339,676},{ 842631,88},{ 956813,12},{ 48599,605},{ 255610,486},{ 760005,113},{ 319700,494},{ 472223,458},{ 147567,601},{ 11984,443},{ 112466,329},{ 409645,446},{ 749117,78},{ 110427,125},{ 71116,483},{ 956831,2},{ 904586,29},{ 46017,572},{ 200345,722},{ 397607,30},{ 761673,121},{ 465261,207},{ 917092,64},{ 110059,829},{ 45979,66},{ 930771,17},{ 32862,244},{ 34596,741},{ 681702,186},{ 859015,102},{ 189833,369},{ 521438,363},{ 261129,573},{ 668551,169},{ 399195,524},{ 872734,69},{ 208618,268},{ 910072,64},{ 734570,113},{ 967051,19},{ 977497,12},{ 71478,823},{ 937463,57},{ 840163,159},{ 337207,380},{ 556917,371},{ 524403,278},{ 27320,54},{ 878660,9},{ 100321,114},{ 318485,104},{ 180200,211},{ 710236,69},{ 530568,457},{ 368071,512},{ 666021,226},{ 574048,218},{ 292789,625},{ 231791,293},{ 951996,25},{ 186480,771},{ 988308,9},{ 211597,453},{ 718902,274},{ 272083,233},{ 745,997},{ 673882,81},{ 651341,28},{ 376243,1},{ 969447,20},{ 737078,174},{ 26445,214},{ 396293,216},{ 121937,589},{ 401064,216},{ 971323,9},{ 674783,168},{ 614149,105},{ 135590,726},{ 288019,658},{ 459373,317},{ 835136,84},{ 563461,266},{ 326173,262},{ 584176,187},{ 362380,102},{ 236503,650},{ 198918,509},{ 5226,479},{ 297406,249},{ 568116,397},{ 792502,71},{ 88980,757},{ 816098,36},{ 66343,341},{ 367994,509},{ 622342,151},{ 916029,26},{ 828293,29},{ 131125,496},{ 304487,568},{ 172980,692},{ 850532,76},{ 371903,413},{ 701314,143},{ 76672,807},{ 889885,95},{ 916240,4},{ 123568,501},{ 414049,282},{ 380098,200},{ 318550,304},{ 163351,833},{ 437997,552},{ 423542,340},{ 825604,98},{ 444350,165},{ 817201,144},{ 751559,174},{ 114587,832},{ 617122,246},{ 807234,84},{ 360755,22},{ 395727,319},{ 538754,119},{ 947645,39},{ 436982,244},{ 510489,44},{ 669792,293},{ 159495,518},{ 995688,3},{ 747178,196},{ 917383,84},{ 20172,692},{ 899831,24},{ 995128,2},{ 775010,203},{ 503595,129},{ 729913,143},{ 414644,473},{ 737257,27},{ 595022,347},{ 750561,162},{ 162161,43},{ 623656,120},{ 34303,726},{ 442362,270},{ 197203,125},{ 53801,886},{ 254786,146},{ 725842,220},{ 520965,283},{ 462314,507},{ 95020,333},{ 399162,305},{ 828258,44},{ 744613,49},{ 363546,332},{ 502801,197},{ 650846,106},{ 553239,77},{ 467361,401},{ 436351,543},{ 538160,289},{ 548894,222},{ 655196,278},{ 690294,302},{ 713053,23},{ 254568,508},{ 484654,365},{ 743829,40},{ 331249,237},{ 933199,56},{ 351160,233},{ 557130,268},{ 387536,397},{ 131635,238},{ 204404,609},{ 849265,63},{ 712476,126},{ 198455,744},{ 874026,14},{ 185046,44},{ 145489,2},{ 654762,313},{ 398163,349},{ 104068,19},{ 440598,263},{ 666051,139},{ 477504,490},{ 622929,57},{ 152410,225},{ 814652,99},{ 210306,281},{ 799924,117},{ 824259,110},{ 323580,10},{ 397965,400},{ 328134,504},{ 863160,143},{ 146542,862},{ 238783,161},{ 794669,22},{ 527490,290},{ 536452,189},{ 604107,329},{ 910825,5},{ 953612,13},{ 552041,273},{ 972926,3},{ 592277,62},{ 646552,83},{ 692876,184},{ 472410,317},{ 763967,5},{ 735180,191},{ 103537,717},{ 108957,779},{ 255472,23},{ 171880,542},{ 393119,341},{ 776255,211},{ 228807,184},{ 952074,11},{ 885808,78},{ 579988,42},{ 20847,49},{ 298506,315},{ 655576,284},{ 52097,743},{ 104061,787},{ 109352,592},{ 748566,217},{ 2463,887},{ 32976,784},{ 189617,713},{ 271058,374},{ 429296,560},{ 809090,29},{ 998215,0},{ 707975,94},{ 707997,174},{ 872633,84},{ 462266,327},{ 721819,246},{ 794759,163},{ 606300,247},{ 861636,122},{ 340414,537},{ 808027,149},{ 632228,327},{ 180653,461},{ 28313,405},{ 178779,349},{ 491800,194},{ 84267,610},{ 561867,183},{ 485487,268},{ 213404,566},{ 380259,581},{ 431017,521},{ 865840,116},{ 351585,261},{ 636938,338},{ 570504,134},{ 796618,49},{ 36055,627},{ 533904,467},{ 256880,38},{ 242864,751},{ 216746,142},{ 467702,372},{ 479771,237},{ 4082,91},{ 976362,6},{ 164757,759},{ 248446,270},{ 283539,110},{ 235362,12},{ 55323,815},{ 458676,235},{ 630251,72},{ 84579,727},{ 590590,312},{ 851426,1},{ 28996,937},{ 717246,290},{ 632555,335},{ 923439,59},{ 13888,618},{ 690885,82},{ 183242,456},{ 705690,59},{ 125140,470},{ 223780,575},{ 41792,816},{ 344536,638},{ 87662,811},{ 537475,215},{ 161140,87},{ 954032,37},{ 512858,342},{ 249680,233},{ 475082,520},{ 413260,367},{ 838425,103},{ 435392,280},{ 900253,99},{ 166697,735},{ 944264,1},{ 342482,240},{ 802181,114},{ 9241,17},{ 243076,524},{ 869986,90},{ 597238,1},{ 869957,41},{ 793504,61},{ 442652,537},{ 898397,17},{ 323466,136},{ 692994,272},{ 545657,171},{ 964936,37},{ 948400,26},{ 183540,485},{ 633193,49},{ 328932,411},{ 429018,148},{ 846072,156},{ 826896,133},{ 796394,196},{ 967870,21},{ 907165,64},{ 545323,2},{ 421294,464},{ 952487,35},{ 208154,308},{ 96271,722},{ 400702,213},{ 672001,238},{ 24745,751},{ 429650,91},{ 183202,816},{ 207128,83},{ 666902,249},{ 965469,8},{ 965537,8},{ 802398,25},{ 727002,96},{ 292453,553},{ 916965,18},{ 474981,61},{ 39916,613},{ 452831,349},{ 864326,33},{ 293996,564},{ 205660,91},{ 434825,85},{ 402489,151},{ 784195,157},{ 255808,161},{ 624491,203},{ 611449,63},{ 663777,82},{ 850741,142},{ 489949,477},{ 409934,258},{ 786335,179},{ 206644,394},{ 822516,16},{ 356656,553},{ 687112,104},{ 554811,74},{ 138548,847},{ 891434,72},{ 647847,8},{ 377313,155},{ 471652,43},{ 624029,374},{ 59234,745},{ 287600,614},{ 706802,10},{ 205852,630},{ 538773,94},{ 923201,5},{ 420894,558},{ 737184,84},{ 480685,224},{ 960392,36},{ 122023,25},{ 816168,161},{ 125244,130},{ 750887,76},{ 606230,396},{ 529518,430},{ 238470,483},{ 746249,176},{ 251593,591},{ 698626,239},{ 887569,77},{ 778146,141},{ 840718,73},{ 473152,95},{ 354719,574},{ 925537,41},{ 820531,32},{ 477694,308},{ 804774,160},{ 184889,49},{ 392597,358},{ 569538,165},{ 686029,282},{ 32248,484},{ 639169,318},{ 68632,68},{ 380683,256},{ 229337,224},{ 265522,725},{ 685888,280},{ 986736,13},{ 938717,58},{ 401051,178},{ 297099,193},{ 59803,669},{ 766367,103},{ 390884,512},{ 430898,259},{ 58320,61},{ 404090,430},{ 454918,167},{ 726897,96},{ 970409,2},{ 753853,1},{ 768504,22},{ 681921,144},{ 610160,219},{ 451467,324},{ 17833,771},{ 938574,43},{ 456600,215},{ 357840,469},{ 422101,378},{ 922341,26},{ 809452,11},{ 505530,246},{ 47189,743},{ 95160,196},{ 766056,83},{ 194185,530},{ 383844,393},{ 72703,22},{ 422246,122},{ 132048,643},{ 269240,229},{ 781887,107},{ 956713,2},{ 518947,7},{ 722386,94},{ 651692,65},{ 459200,228},{ 655423,35},{ 335066,661},{ 604296,308},{ 980286,15},{ 956354,13},{ 741667,54},{ 186746,792},{ 984273,14},{ 260054,64},{ 850682,59},{ 385503,193},{ 381560,486},{ 720801,203},{ 256914,106},{ 697454,231},{ 913027,37},{ 592327,163},{ 731157,127},{ 838461,162},{ 154861,105},{ 574449,123},{ 101760,129},{ 484362,369},{ 136219,848},{ 207767,61},{ 556669,289},{ 113030,130},{ 429249,277},{ 394319,168},{ 185642,151},{ 681801,198},{ 594457,60},{ 819949,55},{ 501218,303},{ 83781,646},{ 78044,245},{ 268277,327},{ 815225,117},{ 749253,16},{ 613301,175},{ 681627,260},{ 918602,76},{ 914800,84},{ 39810,516},{ 725219,134},{ 625765,95},{ 62315,150},{ 444898,72},{ 577770,318},{ 54024,466},{ 563816,209},{ 577956,36},{ 218785,238},{ 973815,5},{ 188317,482},{ 871181,117},{ 255233,139},{ 992238,0},{ 550093,82},{ 961077,24},{ 737643,201},{ 795088,178},{ 480751,40},{ 594057,293},{ 518845,317},{ 825333,73},{ 868796,25},{ 614255,0},{ 444944,52},{ 765757,173},{ 314197,596},{ 919772,3},{ 381003,427},{ 416116,200},{ 279640,414},{ 966376,25},{ 496144,248},{ 194778,457},{ 439048,444},{ 483538,436},{ 785426,215},{ 25496,155},{ 564810,174},{ 560540,47},{ 230302,428},{ 924304,43},{ 319456,461},{ 280603,385},{ 785634,73},{ 111612,856},{ 830878,71},{ 164871,10},{ 202977,559},{ 345020,82},{ 585478,188},{ 759810,192},{ 501895,170},{ 329225,605},{ 835666,90},{ 149446,118},{ 581226,195},{ 445090,220},{ 752538,88},{ 371707,327},{ 320870,649},{ 306577,626},{ 639191,194},{ 301088,498},{ 561342,370},{ 468160,18},{ 736858,96},{ 789305,46},{ 987437,6},{ 577057,411},{ 250610,732},{ 925238,11},{ 75616,469},{ 615648,65},{ 694242,90},{ 900980,93},{ 933610,36},{ 893135,92},{ 166549,403},{ 298036,163},{ 580226,95},{ 677468,120},{ 916894,74},{ 701659,107},{ 467046,204},{ 624772,262},{ 577054,298},{ 161521,460},{ 533177,107},{ 882606,105},{ 24136,203},{ 431327,6},{ 182039,313},{ 68427,1},{ 560978,335},{ 200885,795},{ 512531,169},{ 297005,550},{ 780651,72},{ 514519,473},{ 839441,14},{ 29098,349},{ 917216,54},{ 870254,77},{ 778828,217},{ 237012,432},{ 873478,93},{ 764488,104},{ 431673,299},{ 670123,275},{ 651108,60},{ 60809,671},{ 839582,149},{ 472374,399},{ 401657,57},{ 574246,17},{ 504242,121},{ 790459,159},{ 250256,511},{ 449400,222},{ 894610,41},{ 122594,486},{ 105196,785},{ 564119,250},{ 367555,486},{ 917094,53},{ 571076,272},{ 406912,135},{ 104407,424},{ 294732,709},{ 984705,13},{ 684761,219},{ 427736,332},{ 982066,2},{ 991275,0},{ 425329,354},{ 698569,168},{ 132946,834},{ 493787,407},{ 248677,147},{ 874686,63},{ 550446,298},{ 578912,187},{ 223060,66},{ 214647,139},{ 444704,173},{ 971475,22},{ 237027,65},{ 118762,510},{ 469492,280},{ 325922,17},{ 486221,484},{ 410241,185},{ 257325,529},{ 989675,2},{ 198099,375},{ 687167,80},{ 409217,107},{ 819101,188},{ 603207,391},{ 510023,404},{ 726197,270},{ 484950,215},{ 546482,167},{ 822750,105},{ 166582,616},{ 518150,56},{ 133822,371},{ 200406,717},{ 97871,657},{ 29573,492},{ 691109,65},{ 808741,150},{ 750266,18},{ 822040,179},{ 306681,522},{ 214393,88},{ 894715,102},{ 704205,272},{ 180183,605},{ 329765,484},{ 406200,499},{ 295252,640},{ 650762,169},{ 521668,46},{ 176279,482},{ 203608,594},{ 714798,128},{ 617015,146},{ 826144,119},{ 340650,594},{ 562244,279},{ 111793,634},{ 304040,26},{ 906078,7},{ 856098,84},{ 93397,699},{ 953959,26},{ 598922,306},{ 636273,293},{ 50466,815},{ 716599,184},{ 329928,672},{ 531336,43},{ 91251,896},{ 987084,8},{ 184120,562},{ 941743,29},{ 21485,362},{ 923492,43},{ 714683,230},{ 895730,48},{ 371388,382},{ 835312,109},{ 864921,22},{ 769458,47},{ 879842,32},{ 643820,253},{ 488630,144},{ 405344,585},{ 955381,3},{ 390744,120},{ 491755,250},{ 771000,128},{ 179915,296},{ 921832,78},{ 306396,251},{ 607328,127},{ 678963,264},{ 944460,0},{ 354103,544},{ 435690,513},{ 3615,433},{ 213496,429},{ 129860,560},{ 105082,551} };
            peopleR = ReconstructQueue(people);

            int kthEleValu = FindKthElement(new int[] { 3,4,8,3,4},3);
            kthEleValu = FindKthElement(new int[] { 3, 4, 8, 3, 4 }, 4);
            kthEleValu = FindKthElement(new int[] { 1, 2, 3, 4, 5 }, 5);

            kthEleValu = FindKthElement(new int[] { 1, 2, 3, 4, 5 }, 2);

            kthEleValu = FindKthElement(new int[] { 1,5,1 ,2, 3, 4, 5 }, 4);
            kthEleValu = FindKthElement(new int[] { 1, 5, 1, 2, 3, 4, 5 }, 5);

            int dd = Divide(8, 2);
            dd = Divide(15, 2);
            dd = Divide(16, 3);

            ri = FirstMissingPositive(new int[] { 2, 3, 7, 6, 8, -1, -10, 15 });
            ri = FirstMissingPositive(new int[] { 2, 3, -7, 6, 8, 1, -10, 15 });
            ri = FirstMissingPositive(new int[] { 1, 1, 0, -1, -2 });
            ri = FirstMissingPositive(new int[] { 1, 2, 0 });

            testRob();

            TreeNode ns1 = new TreeNode(-1) ;
            TreeNode ns2 = new TreeNode(2);
            TreeNode ns3 = new TreeNode(-3);
            TreeNode ns4 = new TreeNode(4);
            TreeNode ns5 = new TreeNode(-5);
            TreeNode ns6 = new TreeNode(6);
            TreeNode ns7 = new TreeNode(7);
            ns1.left = ns2;
            ns1.right = ns3;
            ns2.left = ns4;
            ns2.right = ns5;
            ns4.left = ns6;
            var serils = SerializeBinaryTree(ns1);

            int cr =  PathSum(ns1, 1);
            cr = PathSum(ns1, 3);
            cr = PathSum(ns1, 2);

            var ra = FindAnagrams("cbaebabacd", "abc");
            ra = FindAnagrams("abab", "ab");

            ra = FindAnagrams("acbca", "ac");
            ra = FindAnagrams("abab", "ab");

            TreeNode tn1 = new TreeNode(10);
            TreeNode tn2 = new TreeNode(5);
            TreeNode tn3 = new TreeNode(-3);

            TreeNode tn4 = new TreeNode(3);
            TreeNode tn5 = new TreeNode(2);
            TreeNode tn6 = new TreeNode(11);
            TreeNode tn7 = new TreeNode(7);

            TreeNode tn8 = new TreeNode(3);
            TreeNode tn9 = new TreeNode(-2);
            TreeNode tn10 = new TreeNode(1);
            tn1.left = tn2;
            tn1.right = tn3;
            tn2.left = tn4;
            tn2.right = tn5;
            tn3.right = tn6;
            tn4.left =  tn7;
            tn4.right = tn8;
            tn5.right = tn10;

            cr = PathSum(tn1, 8);

            var countS = CountSmaller(new int[] { 5, 2, 6, 1 });
            countS = CountSmaller(new int[] { 5, 2, 6, 1,2,2,1 });
            countS = CountSmaller(new int[] { 26, 78, 27, 100, 33, 67, 90, 23, 66, 5, 38, 7, 35, 23, 52, 22, 83, 51, 98, 69, 81, 32, 78, 28, 94, 13, 2, 97, 3, 76, 99, 51, 9, 21, 84, 66, 65, 36, 100, 41 });
            countS = CountSmaller(new int[] { 26, 78, 27, 200, 33, 67, 90, 23, 66, 5, 38, 7, 35, 23, 52, 22, 83, 51, 98, 69, 81, 32, 78, 28, 94, 13, 2, 97, 3, 76, 99, 51, 9, 21, 84, 66, 65, 36, 100, 41 });

        }

        public IList<int> CountSmaller(int[] nums)
        {
            BstTree bstTree = new BstTree();
            BstTreeNode root = bstTree.CreateBstTreeNode(nums);
            return bstTree.GetAnswer();

        }

        public int PathSum(TreeNode root, int sum)
        {
            if (root == null) return 0;
            int result = Dfs(root,sum);
            if(root.left != null)
            {
                result += PathSum(root.left, sum);
            }
            if (root.right != null)
            {
                result += PathSum(root.right, sum);
            }
            return result;
        }
        int Dfs(TreeNode root, int sum)
        {
            int result = 0;
            sum -= root.val;
            if (sum == 0)
            {
                result++;
            }

            if (root.left != null)
            {
                result += Dfs(root.left, sum );
            }

            if (root.right != null)
            {
                result += Dfs(root.right, sum );
            }
            return result;
        }

        public IList<int> FindAnagrams(string s, string p)
        {
            List<int> result = new List<int>();
            if (string.IsNullOrEmpty(s)) return result;

            char[] pa = new char[p.Length];
            char[] tmp = new char[p.Length];

            int len = p.Length;
            Copy(s, pa, 0, len);
            Array.Sort(pa);
            for (int i = 0; i < s.Length - p.Length + 1; i++)
            {
                Copy(s, tmp, i, p.Length);
                Array.Sort(tmp);
                bool isSame = true;
                for (int j = 0; j < len; j++)
                {
                    if (tmp[j] != pa[j])
                    {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) result.Add(i);
            }
            return result;
        }
        void Copy(string s, char[] tmp, int start, int len)
        {
            for (int i = 0; i < len; i++)
            {
                tmp[i] = s[start + i];
            }
        }


        

        

        string SerializeBinaryTree(TreeNode root)
        {
            List<int> list = new List<int>();
            SerializeBinaryTree(root, list);
            string str = "";
            for(int i = 0;i < list.Count; i++)
            {
                if(i > 0)
                {
                    str += "," ;
                }
                str += list[i] != int.MinValue ? list[i].ToString() : "null";
            }
            return str;
        }
        void SerializeBinaryTree(TreeNode root, List<int> list)
        {
            if(root != null)
            {
                list.Add(root.val);
                SerializeBinaryTree(root.left, list);
                SerializeBinaryTree(root.right, list);
            }
            else
            {
                list.Add(int.MinValue);
            }
            
        }
        TreeNode DeSerializeBinaryTree(string str)
        {

            string[] strs = str.Split(new char[] { ',' });
            //return DeSerializeBinaryTree(strs);
            return null;
        }
        int indexD = 0;
        //
        void DeSerializeBinaryTree(string []strs,int start,TreeNode parent)
        {
            if(strs[indexD] != "null")
            {
                //TreeNode node = new TreeNode(int.Parse(strs[indexD]));
                //if(parent.left !)
                ////parent.left = DeSerializeBinaryTree(strs,  parent);
                //return root;
            }
            


        }
        void testRob()
        {
            TreeNode n1 = new TreeNode(6);
            TreeNode n2 = new TreeNode(2);
            TreeNode n3 = new TreeNode(3);
            TreeNode n4 = new TreeNode(1);
            TreeNode n5 = new TreeNode(7);
            n1.left = n2;
            n1.right = n3;
            n3.left = n4;
            n3.right = n5;
            int ri = Rob(n1);

            ri = Rob(new int[] { 1,2});
            ri = Rob(new int[] { 1 });
            ri = Rob(new int[] { 3,1, 2 });
            ri = Rob(new int[] { 3, 7, 2 });

            var listSArr = KSmallestPairs(new int[] { 1,2,4,100,101}, new int[] { 6,9,10}, 6);
            listSArr = KSmallestPairs(new int[] { 1, 2, 4, 100, 101 }, new int[] { 6, 9, 10 }, 15);

            listSArr = KSmallestPairs(new int[] { 1 }, new int[] { 1 }, 1);
            listSArr = KSmallestPairs(new int[] { }, new int[] {  }, 5);

            listSArr = KSmallestPairs(new int[] { 1, 1, 2 }, new int[] { 1, 2, 3 }, 10);

            int[] nums = new int[] { 1, 5, 1, 1, 6, 4 };
            WiggleSort(nums);
            nums = new int[] { 1, 5, 1, 1, 6, 4 };
            WiggleSort(nums);

            nums = new int[] { 1, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 2 };
            WiggleSort(nums);

            nums = new int[] {1,4,5,5 };//[5,4,5,1]
            WiggleSort(nums);

            nums = new int[] { 4, 5, 5, 6 };//[4,5,6,5]
            WiggleSort(nums);

            MinHeap mh = new MinHeap(10);
            mh.Push(new Tuple() { Value = 9, Column = 1, Row = 2 });
            mh.Push(new Tuple() { Value = 10, Column = 1, Row = 2 });
            mh.Push(new Tuple() { Value = 11, Column = 1, Row = 2 });
            mh.Push(new Tuple() { Value = 8,Column = 1, Row = 2 });
            mh.Push(new Tuple() { Value = 7, Column = 1, Row = 2 });

            var top = mh.Top();
            mh.Pop();
            top = mh.Top();
            mh.Pop();
            top = mh.Top();
            mh.Pop();
            top = mh.Top();
            mh.Pop();

            int[,] mat = new int[,] { { 1, 5, 8 }, { 2, 6, 9 }, { 3, 7, 10 } };
            ri = KthSmallest(mat,6);

            mat = new int[,] { { 1, 5, 9 }, { 10, 11, 13 }, { 12, 13, 15 } };
            ri = KthSmallest(mat, 8);


            int trapWContain = Trap(new int[] { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 });

            int rindex = SearchInsert(new int[] { 1, 3, 5, 6 },5);
            rindex = SearchInsert(new int[] { 1, 3, 5, 6 }, 2);
            rindex = SearchInsert(new int[] { 1, 3, 5, 6 }, 7);
            rindex = SearchInsert(new int[] { 1, 3, 5, 6 }, 0);
            rindex = SearchInsert(new int[] { 1, 3, 5, 6 }, 4);
            rindex = SearchInsert(new int[] { 1, 3 }, 2);

            string rstring = Convert("PAYPALISHIRING", 3);

            rstring = Convert("PAYPALISHIRING", 2);

            rstring = Convert("PAYPALISHIRING", 1);


            TreeNode bst1 = new TreeNode(5);
            TreeNode bst2 = new TreeNode(2);
            TreeNode bst3 = new TreeNode(6);
            bst1.left = bst2;
            bst1.right = bst3;
            bool bb = IsValidBST(bst1);
        }
        bool isBST = true;

        
        public bool IsValidBST(TreeNode root)
        {
            return isValidBST(root, Double.MinValue, Double.MaxValue);
        }

        public bool isValidBST(TreeNode p, double min, double max)
        {
            if (p == null)
                return true;

            if (p.val <= min || p.val >= max)
                return false;

            return isValidBST(p.left, min, p.val) && isValidBST(p.right, p.val, max);
        }


        //public bool IsValidBST(TreeNode root)
        //{
        //    //isBST = true;
        //    //traverse(root);
        //    //return isBST;
        //    // traverse the tree in inorder fashion and keep track of prev node
        //    if (root)
        //    {
        //        if (!isBST(root->left))
        //            return false;

        //        // Allows only distinct valued nodes 
        //        if (prev != NULL && root->data <= prev->data)
        //            return false;

        //        prev = root;

        //        return isBST(root->right);
        //    }

        //    return true;

        //}
        //bool CheckBST(TreeNode root)
        //{
        //    int maxL = GetMax(root.left) ;
        //    int minR = GetMin(root.right);
        //    if(maxL < root.val && minR )
        //}

        void traverse(TreeNode root)
        {
            if (root == null) return;

            if (root.left != null)
            {
                if (root.left.val >= root.val)
                    isBST = false;
                else
                    traverse(root.left);
            }
            if (root.right != null)
            {
                if (root.right.val <= root.val)
                    isBST = false;
                else
                    traverse(root.right);
            }
        }

        public string Convert(string s, int numRows)
        {
            if (numRows == 1) return s;
            StringBuilder[] sbs = new StringBuilder[numRows];
            for (int i = 0; i < sbs.Length; i++)
            {
                sbs[i] = new StringBuilder();
            }

            int indexSb = 0;
            int delta = 1;
            sbs[0].Append(s[0]);
            indexSb++;
            for (int i = 1; i < s.Length; i++)
            {
                sbs[indexSb].Append(s[i]);
                indexSb += delta;
                if (indexSb == numRows)
                {
                    delta = -delta;
                    indexSb -= 2;
                }
                else if (indexSb < 0)
                {
                    delta = -delta;
                    indexSb = 1;
                }
            }
            string result = "";
            foreach (var sb in sbs)
            {
                result += sb.ToString();
            }
            return result;
        }
        public int SearchInsert(int[] nums, int target)
        {
            int len = nums.Length;
            if (target < nums[0]) return 0;
            if (target > nums[len - 1]) return len;
            int l = 0, r = len - 1;
            while (l <= r)
            {
                int mid = l + (r - l) / 2;
                if (nums[mid] == target)
                {
                    return mid;
                }
                else if (target < nums[mid])
                {
                    r = mid - 1;

                }
                else
                {
                    l = mid + 1;
                }

            }
            return r + 1;
        }

        
        //-------------------------
        public int Trap(int[] height)
        {
            int result = 0;

            if (height == null || height.Length <= 2)
                return result;

            int []left = new int[height.Length];
            int []right = new int[height.Length];

            //scan from left to right
            int max = height[0];
            left[0] = height[0];
            for (int i = 1; i < height.Length; i++)
            {
                if (height[i] < max)
                {
                    left[i] = max;
                }
                else {
                    left[i] = height[i];
                    max = height[i];
                }
            }

            //scan from right to left
            max = height[height.Length - 1];
            right[height.Length - 1] = height[height.Length - 1];
            for (int i = height.Length - 2; i >= 0; i--)
            {
                if (height[i] < max)
                {
                    right[i] = max;
                }
                else {
                    right[i] = height[i];
                    max = height[i];
                }
            }

            
            for (int i = 0; i < height.Length; i++)
            {
                result += Math.Min(left[i], right[i]) - height[i];
            }

            return result;
        }

        //------------------------
        public int KthSmallest(int[,] mat, int k)
        {
            int len0 = mat.GetLength(0);
            int len1 = mat.GetLength(1);
            MinHeap minHeap = new MinHeap(len1);
            for (int i = 0; i <len1; i++)
            {
                minHeap.Push(new Tuple() { Value = mat[0, i], Row = 0, Column = i });
            }
            Tuple result = new Tuple();
            for (int i = 0; i < k; i++)
            {
                result = minHeap.Top();
                minHeap.Pop();
                if (result.Row == mat.GetLength(0) - 1)
                    continue;
                int nextRow = result.Row + 1;
                int nextCol = result.Column;
                minHeap.Push(new Tuple() { Value = mat[nextRow, nextCol], Row = nextRow, Column = nextCol });
            }

            return result.Value;
        }

        public void WiggleSort(int[] nums)
        {
            int median = FindKthElement(nums, (nums.Length + 1) / 2);
            int odd = 1;
            int even = nums.Length % 2 == 0 ? nums.Length - 2 : nums.Length - 1;
            int[] tmpArr = new int[nums.Length];
            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] > median)
                {
                    tmpArr[odd] = nums[i];
                    odd += 2;
                    continue;
                }
                if (nums[i] < median)
                {
                    tmpArr[even] = nums[i];
                    even -= 2;
                    continue;
                }
            }
            while (odd < nums.Length)
            {
                tmpArr[odd] = median;
                odd += 2;
            }
            while (even >= 0)
            {
                tmpArr[even] = median;
                even -= 2;
            }
            for (int i = 0; i < nums.Length; i++)
            {
                nums[i] = tmpArr[i];
            }

        }
        

        private int A(int[] nums, int i)
        {
            int n = nums.Length;
            return nums[(1 + 2 * i) % (n | 1)];
        }
        //public void WiggleSort(int[] nums)
        //{
        //    int mid = FindKthElement(nums, (nums.Length + 1) / 2);
        //    int even = nums.Length % 2 == 0 ? nums.Length - 2 : nums.Length - 1;
        //    int n = nums.Length, i = 0, j = 0, k = n - 1;
        //    while (j <= k)
        //    {
        //        if (A(nums, j) > mid)
        //        {
        //            swap(A(i++), A(j++));
        //        }
        //        else if {
        //            if (A(j) < mid) swap(A(j), A(k--));
        //        }
        //        else ++j;
        //    }

        //}
        public void swap(int[] nums, int i)
        {
            int tmp = nums[i];
            nums[i] = nums[i - 1];
            nums[i - 1] = tmp;
        }
        void swap(int[] a, int i, int j)
        {
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
        public int FindKthElement(int[] a, int k)
        {
            if (k > a.Length) return -1;
            return FindKthElement(a, k - 1, 0, a.Length - 1);
        }

        int FindKthElement(int[] a, int k, int left, int right)
        {

            int index = Partition(a, left, right);
            if (index == k) return a[index];
            if (index > k)
            {
                right = index - 1;
            }
            else
            {
                left = index + 1;
            }
            return FindKthElement(a, k, left, right);
        }
        int Partition(int[] a, int left, int right)
        {
            int pivot = a[right];
            int l = left, r = right;
            int i = left, j = left;
            for (; i <= right - 1; i++)
            {
                if (a[i] <= pivot)
                {
                    Swap(a, i, j);
                    j++;
                }

            }
            //elements on the j must be greater than or equal to element on index right 
            Swap(a, right, j);
            return j;
        }
        void Swap(int[] a, int i, int j)
        {
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }



        //public void WiggleSort(int[] nums)
        //{
        //    Shuffle(nums);
        //    for (int i = 0; i < nums.Length; i++)
        //        if (i % 2 == 1)
        //        {
        //            if (nums[i - 1] > nums[i]) swap(nums, i);
        //        }
        //        else if (i != 0 && nums[i - 1] < nums[i]) swap(nums, i);

        //}
        //void Shuffle(int[] nums)
        //{
        //    Array.Sort(nums);
        //    for (int i = 1; i < nums.Length; i++)
        //    {
        //        if (nums[i - 1] == nums[i])
        //        {
        //            int j = i + 1;
        //            while (j < nums.Length && nums[j] == nums[i])
        //            {
        //                j++;
        //            }
        //            if (j < nums.Length)
        //            {
        //                swap(nums, i, j);
        //            }
        //            else
        //            {
        //                j = 0;
        //                while (j < nums.Length && nums[j] == nums[i])
        //                {
        //                    j++;
        //                }
        //                if (j < nums.Length)
        //                {
        //                    swap(nums, i, j);
        //                }
        //            }
        //        }
        //    }
        //}
        //public void swap(int[] nums, int i)
        //{
        //    int tmp = nums[i];
        //    nums[i] = nums[i - 1];
        //    nums[i - 1] = tmp;
        //}
        //void swap(int[] a, int i, int j)
        //{
        //    int tmp = a[i];
        //    a[i] = a[j];
        //    a[j] = tmp;
        //}

        bool SameDirection(int a, int b, int c)
        {
            if ((a - b < 0 && b - c < 0) || (a - b > 0 && b - c > 0))
                return true;

            return false;
        }
        
        public IList<int[]> KSmallestPairs(int[] nums1, int[] nums2, int k)
        {
            int l1 = nums1.Length, l2 = nums2.Length;
            if (l1 == 0 || l2 == 0) return new List<int[]>();

            int []idxes = new int[l1];
            for(int i = 0;i < idxes.Length; i++)
            {
                idxes[i] = -1;
            }
            int maxX = 0;
            IList<int[]> listResult = new List<int[]>();
            while (k >  0)
            {
                int x = 0, y = 0;
                int min = int.MaxValue;
                int newMaxIndex = Math.Min(maxX + 1, l1 - 1);
                if (newMaxIndex == l1 - 1 && idxes[newMaxIndex] >= l2 - 1) break;
                for(int i = 0;i <= newMaxIndex; i ++)
                {
                    if(idxes[i] + 1 < nums2.Length)
                    {
                        if(min > nums1[i] + nums2[idxes[i] + 1])
                        {
                            min = nums1[i] + nums2[idxes[i] + 1];
                            x = i;
                            y = idxes[i] + 1;
                            if (maxX < x) maxX = x;
                        }
                    }
                    
                }
                idxes[x] = y;
                listResult.Add(new int[] { nums1[x], nums2[y] });
                k--;
            }
            return listResult;
        }
        //M(i) maximum amount to rob until ith house
        //M(i) = Max{M(i - 1), nums[i] + M(i - 2)} 
        public int Rob(int[] nums)
        {
            if (nums.Length == 0) return 0;
            int mi_1 = nums[0], mi_2 = 0;
            for(int i = 1; i < nums.Length;i ++)
            {
                int m = Math.Max(mi_1,mi_2 + nums[i]);
                mi_2 = mi_1;
                mi_1 = m;
            }
            return mi_1;
        }
        public int Rob(TreeNode root)
        {
            int[] result = Rob1(root);
            return Math.Max(result[0], result[1]);
        }
        private int[] Rob1(TreeNode root)
        {
            //root[0] = root.val + sumof grandchildren
            //root[1] = sum of childrend
            if (root == null)
            {
                return new int[] { 0, 0 };
            }
            int[] left = Rob1(root.left);
            int[] right = Rob1(root.right);
            int[] result = new int[2];
            result[0] = root.val + left[1] + right[1];
            result[1] = Math.Max(left[0],left[1]) + Math.Max(right[0], right[1]);
            
            return result;
        }
       
        int SplitPosAndNegative(int []arr)
        {
            int size = arr.Length;
            int j = 0, i;
            for (i = 0; i < size; i++)
            {
                if (arr[i] > 0)
                {
                    Swap(arr,i,j);
                    j++;  
                }
            }

            return j;
        }
        int findMissingPositive(int []arr, int size)
        {
            int i;
            for (i = 0; i < size; i++)
            {
                if (Math.Abs(arr[i]) - 1 < size && arr[Math.Abs(arr[i]) - 1] > 0)
                    arr[Math.Abs(arr[i]) - 1] = -arr[Math.Abs(arr[i]) - 1];
            }

            for (i = 0; i < size; i++)
                if (arr[i] > 0)
                    return i + 1;  // 1 is added becuase indexes start from 0

            return size + 1;
        }
        public int FirstMissingPositive(int[] nums)
        {
            int size = SplitPosAndNegative(nums);

            return findMissingPositive(nums, size);
        }

        //public int FillValey(int[] height)
        //{

        //}
        //quick select, O(n)
        //http://www.cs.yale.edu/homes/aspnes/pinewiki/QuickSelect.html
        //http://stackoverflow.com/questions/8783408/why-is-the-runtime-of-the-selection-algorithm-on
        //public int FindKthElement(int[] a, int k)
        //{
        //    if (k > a.Length) return -1;
        //    return FindKthElement(a, k - 1, 0, a.Length - 1);
        //}

        //int FindKthElement(int[] a, int k, int left, int right)
        //{
        //    int m = (left + right) / 2;
        //    int index = Partition(a, a[m], left, right);
        //    if (index - left == k) return a[index];
        //    if(index - left > k)
        //    {
        //        right = index - 1;
        //    }else
        //    {
        //        k -= index + 1 - left;
        //        left = index + 1;
        //    }
        //    return FindKthElement(a, k, left, right);
        //}
        //int Partition(int[] a, int pivot,int left,int right)
        //{
        //    int l = left, r = right;
        //    while(left <= right)
        //    {
        //        while (left <= right &&  a[left] < pivot) left++;
        //        while (left <= right && a[right] > pivot) right--;
        //        if(left <= right)
        //        {
        //            Swap(a, left ++, right --);
        //        }

        //    }
        //    return right + 1;
        //}
        //void Swap(int []a,int i,int j)
        //{
        //    int tmp = a[i];
        //    a[i] = a[j];
        //    a[j] = tmp;
        //}



        //9,2 : 1,2,4,8,16
        //http://www.programcreek.com/2014/05/leetcode-divide-two-integers-java/
        public int Divide(int dividend, int divisor)
        {
            //special cases
            if (divisor == 0 || (dividend == int.MinValue && divisor == -1))
                return int.MaxValue;

            // transform to unsigned int
            bool sign = (dividend > 0) ^ (divisor > 0);
            uint A = (divisor < 0) ? (uint)-divisor : (uint)divisor;
            uint B = (dividend < 0) ? (uint)-dividend : (uint)dividend;
            int ret = 0;

            // shift 32 times
            for (int i = 31; i >= 0; i--)
            {
                if ((B >> i) >= A)
                {
                    ret = (ret << 1) | 0x01;
                    B -= (A << i);   // update B
                }
                else
                    ret = ret << 1;
            }

            if (sign)
                ret = -ret;

            return ret;
        }

        //http://www.codescream.com/ContentDisplay?targetContent=QuickSelect
        //http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-2-expected-linear-time/
        
        public int[,] ReconstructQueue(int[,] people)
        {
            if (people == null) return people;
            int pos = 0;
            int len = people.GetLength(0);
            if (len == 0) return people;

            qSort(people, 0, len - 1);
            HashSet<int> hsAdded = new HashSet<int>();
            for (; pos < len; pos++)
            {
                for (int i = pos; i < len; i++)
                {
                    if (IsFit(people[i, 0], people[i, 1], people, pos))
                    {
                        MoveTo(people, pos, i);
                        break;
                    }
                }
            }
            return people;
        }
        void MoveTo(int[,] people, int i, int j)
        {
            int h = people[j, 0];
            int count = people[j, 1];
            for(int k = j; k > i; k--)
            {
                people[k, 0] = people[k - 1, 0];
                people[k, 1] = people[k - 1, 1];

            }
            people[i, 0] = h;
            people[i, 1] = count;
        }
        public void qSort(int[,] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2, 0];

            while (i <= j)
            {
                while (elements[i, 0].CompareTo(pivot) < 0)
                {
                    i++;
                }

                while (elements[j, 0].CompareTo(pivot) > 0)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    Swap(elements, i, j);
                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                qSort(elements, left, j);
            }

            if (i < right)
            {
                qSort(elements, i, right);
            }
        }
        void Swap(int[,] elements, int i, int j)
        {
            int tmp = elements[i, 0];
            elements[i, 0] = elements[j, 0];
            elements[j, 0] = tmp;

            tmp = elements[i, 1];
            elements[i, 1] = elements[j, 1];
            elements[j, 1] = tmp;
        }
        bool IsFit(int h, int numHigher, int[,] result, int size)
        {
            int count = 0;
            for (int i = 0; i < size; i++)
            {
                if (result[i, 0] >= h)
                {
                    count++;
                    if (count > numHigher) return false;
                }
            }
            return count == numHigher;
        }
        

        //---------------------------
        //public int[,] ReconstructQueue(int[,] people)
        //{
        //    if (people == null) return people;
        //    int pos = 0;
        //    int len = people.GetLength(0);
        //    if (len == 0) return people;

        //    int[,] result = new int[len, 2];
        //    qSort(people,0, len - 1);
        //    HashSet<int> hsAdded = new HashSet<int>();
        //    for (; pos < len; pos++)
        //    {
        //        for (int i = 0; i < len; i++)
        //        {
        //            if (!hsAdded.Contains(i))
        //            {
        //                if (IsFit(people[i, 0], people[i, 1], result, pos))
        //                {
        //                    result[pos, 0] = people[i, 0];
        //                    result[pos, 1] = people[i, 1];
        //                    hsAdded.Add(i);
        //                    break;
        //                }
        //            }
        //        }
        //    }
        //    return result;
        //}
        //public void qSort(int[,] elements, int left, int right)
        //{
        //    int i = left, j = right;
        //    int pivot = elements[(left + right) / 2,0];

        //    while (i <= j)
        //    {
        //        while (elements[i,0].CompareTo(pivot) < 0)
        //        {
        //            i++;
        //        }

        //        while (elements[j,0].CompareTo(pivot) > 0)
        //        {
        //            j--;
        //        }

        //        if (i <= j)
        //        {
        //            // Swap
        //            Swap(elements, i, j);
        //            i++;
        //            j--;
        //        }
        //    }

        //    // Recursive calls
        //    if (left < j)
        //    {
        //        qSort(elements, left, j);
        //    }

        //    if (i < right)
        //    {
        //        qSort(elements, i, right);
        //    }
        //}
        //void Swap(int [,] elements,int i, int j)
        //{
        //    int tmp = elements[i, 0];
        //    elements[i, 0] = elements[j, 0];
        //    elements[j, 0] = tmp;

        //    tmp = elements[i, 1];
        //    elements[i, 1] = elements[j, 1];
        //    elements[j, 1] = tmp;
        //}
        //bool IsFit(int h, int numHigher, int[,] result, int size)
        //{
        //    int count = 0;
        //    for (int i = 0; i < size; i++)
        //    {
        //        if (result[i, 0] >= h)
        //        {
        //            count++;
        //            if (count > numHigher) return false;
        //        }
        //    }
        //    return count == numHigher;
        //}

        //---------------------------

        //public int[,] ReconstructQueue(int[,] people)
        //{
        //    int pos = 0;
        //    int len = people.GetLength(0);
        //    int[,] result = new int[len,2];
        //    int[,] tmpPeople = new int[len, 3];
        //    int nFit = 0;
        //    HashSet<int> hsAdded = new HashSet<int>();
        //    for (; pos < len; pos ++ )
        //    {
        //        for(int i = 0;i < len;i ++)
        //        {
        //            if(!hsAdded.Contains(i))
        //            {
        //                if(IsFit(people[i,0], people[i, 1], result, pos))
        //                {
        //                    tmpPeople[nFit, 0] = people[i, 0];
        //                    tmpPeople[nFit, 1] = people[i, 1];
        //                    tmpPeople[nFit, 2] = i;
        //                    nFit++;
        //                }
        //            }
        //        }
        //        int[] minsFit = FindMinFit(tmpPeople, nFit);
        //        result[pos, 0] = minsFit[0];
        //        result[pos, 1] = minsFit[1];
        //        hsAdded.Add(minsFit[2]);
        //        nFit = 0;
        //    }
        //    return result;
        //}
        //bool IsFit(int h,int numHigher,int[,] result, int size)
        //{
        //    int count = 0;
        //    for(int i =0;i < size;i ++)
        //    {
        //        if(result[i,0] >= h)
        //        {
        //            count++;
        //        }
        //    }
        //    return count == numHigher;
        //}
        //int[] FindMinFit(int[,] people, int size)
        //{
        //    int[] arrMinHeight = new int[3];
        //    arrMinHeight[0] = int.MaxValue;
        //    for (int i = 0; i < size; i++)
        //    {
        //        if (people[i, 0] < arrMinHeight[0])
        //        {
        //            arrMinHeight[0] = people[i, 0];
        //            arrMinHeight[1] = people[i, 1];
        //            arrMinHeight[2] = people[i, 2];
        //        }
        //    }
        //    return arrMinHeight;
        //}
        //[1,9,7,4,5,7,8]  
        //[1,5] 5-6 target = 2 biggest = 5, result = 5  
        //[9,1,10] 10-20 target = 2 biggest = 5, result = 5  
        //minimize sum of contiguous array
        //[1,1,1,1,1] target  = 2

        public int SplitArray(int[] nums, int m)
        {

            if (nums.Length < m) return -1;

            int len = nums.Length;
            long minTarget = 0, maxTarget = 0;
            foreach (var v in nums)
            {
                if (minTarget < v) minTarget = v;
                maxTarget += v;
            }
            while(minTarget < maxTarget)
            {
                long mid = (minTarget + maxTarget) / 2;
                if(canSplit(nums,mid,m))
                {
                    maxTarget = mid;
                }else
                {
                    minTarget = mid + 1;
                }
            }
            return (int)maxTarget;
        }
        /// <summary>
        /// split array which max of sum element can be less than target
        /// </summary>
        /// <param name="nums"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        /// [1,9,8]: target = 9
        private bool canSplit(int[] nums,long target,int m)
        {
            int sum = 0;
            int k = 0;
            for(int i =0; i < nums.Length;i ++)
            {
                if(sum + nums[i] > target)
                {
                    k++;
                    sum = nums[i];
                }else
                {
                    sum += nums[i];
                }
            }
            if(sum < target)
            {
                k++;
            }
            return k <= m;
        }


        //public int SplitArray(int[] nums, int m)
        //{
        //    long max = 0;
        //    long sum = 0;
        //    foreach (var num in nums)
        //    {
        //        max = Math.Max(max, num);
        //        sum += num;
        //    }
        //    long left = max, right = sum;
        //    while (left < right)
        //    {
        //        long mid = (left + right) / 2;
        //        if (can(nums, m, mid))
        //        {
        //            right = mid;
        //        }
        //        else {
        //            left = mid + 1;
        //        }

        //    }
        //    return (int)left;
        //}
        //private bool can(int[] nums, int m, long target)
        //{
        //    int count = 1;
        //    long current = 0;
        //    foreach (var num in nums)
        //    {
        //        if (num > target)
        //        {
        //            return false;
        //        }
        //        if (current + num > target)
        //        {
        //            current = 0;
        //            count++;
        //        }
        //        current += num;
        //    }
        //    return count <= m;

        //}


        //
        public RandomListNode CopyRandomList(RandomListNode head)
        {
            if (head == null) return null;

            RandomListNode cur = head;
            RandomListNode newHead = new RandomListNode(head.label);
            RandomListNode lastNew = newHead;
            RandomListNode newCur = null;
            Dictionary<RandomListNode, RandomListNode> dicOriginDest = new Dictionary<RandomListNode, RandomListNode>();

            dicOriginDest.Add(head, newHead);
            cur = cur.next;
            while (cur != null)
            {
                newCur = new RandomListNode(cur.label);
                lastNew.next = newCur;
                lastNew = newCur;
                dicOriginDest.Add(cur, newCur);
                cur = cur.next;
            }
            cur = head;
            newCur = newHead;
            while (cur != null)
            {
                if (cur.random != null)
                {
                    newCur.random =  dicOriginDest[cur.random];
                }
                cur = cur.next;
                newCur = newCur.next;
            }

            return newHead;
        }

        //[1,3],[2,6],[8,10],[15,18]
        public IList<Interval> Merge(IList<Interval> intervals)
        {
            if (intervals == null || intervals.Count == 0) return intervals;
            var clonedI = intervals.ToArray();
            Array.Sort(clonedI, new IntervalComparer());
            int len = clonedI.Length;
            IList<Interval> result = new List<Interval>();
            Interval lastI = clonedI[0];
            Interval cur = lastI;
            for (int i = 1; i < len; i++)
            {
                cur = clonedI[i];
                if (lastI.end >= cur.start)
                {
                    lastI.end = Math.Max(lastI.end, cur.end);
                }
                else
                {
                    result.Add(lastI);
                    lastI = cur;
                }
            }

            result.Add(lastI);

            return result;
        }

        // [1,3,4,6,6,7,8] [1,1,6,6,9]
        //               i           j    
        //i -> 1, j-> 1
        //i->3, j->1
        //list : 1,6,6
        //better than hashmap
        public int[] Intersection(int []nums1,int []nums2)
        {
            Array.Sort(nums1);
            Array.Sort(nums2);
            int i = 0, len1 = nums1.Length, len2 = nums2.Length;
            int j = 0;

            List<int> list = new List<int>();
            while(i < len1 && j < len2)
            {
                if(nums1[i] == nums2[j])
                {
                    list.Add(nums1[i]);
                    int same = nums1[i];
                    while (i < len1 && j < len2 && nums1[i] == same && nums2[j] == same)
                    {
                        i++;j++;
                    }
                }
                else if(nums1[i] < nums2[j])
                {
                    i++;
                }else
                {
                    j++;
                }
            }
            return list.ToArray();

        }

        //public int[] Intersection(int[] nums1, int[] nums2)
        //{
        //    HashSet<int> hs = new HashSet<int>();
        //    if (nums1.Length < nums2.Length)
        //    {
        //        int[] tmp = nums1;
        //        nums1 = nums2;
        //        nums2 = tmp;
        //    }
        //    for (int i = 0; i < nums2.Length; i++)
        //    {
        //        if (!hs.Contains(nums2[i]))
        //        {
        //            hs.Add(nums2[i]);
        //        }
        //    }
        //    HashSet<int> intersect = new HashSet<int>();
        //    foreach (var x in nums1)
        //    {
        //        if (hs.Contains(x))
        //        {
        //            if (!intersect.Contains(x))
        //                intersect.Add(x);
        //        }
        //    }
        //    return intersect.ToArray();
        //}

        public int Reverse(int x)
        {
            int sign = 1;
            if (x < 0)
            {
                sign = -1;
                x = -x;
            }
            int y = 0;
            int tmp = x;
            try
            {
                while (x > 0)
                {
                    int digit = x % 10;
                    checked
                    {
                        y = digit + y * 10;
                    }
                    
                    x /= 10;
                }
            }catch(Exception exp)
            {
                return 0;
            }
            
            return sign * y;
        }

        //public Int64 Reverse(int x)
        //{
        //    int sign = 1;
        //    uint ux;
        //    if (x < 0)
        //    {
        //        sign = -1;
        //        ux = (uint)(-x);
        //    }else
        //    {
        //        ux = (uint)x;
        //    }
        //    Int64 y = 0;
        //    uint tmp = ux;
        //    while (ux > 0)
        //    {
        //        byte digit = (byte)(ux % 10);
        //        y = digit + y * 10;
        //        ux /= 10;
        //    }
        //    if (sign > 0)
        //        return y;
        //    //x = (int)(y);
        //    //x = -x;
        //    return -y;
        //}
        /// <summary>
        /// 
        /// </summary>
        /// <param name="nums"></param>
        /// <returns></returns>
        public int MaxSubArray(int[] nums)
        {
            if (nums == null || nums.Length == 0) return 0;
            int maxSum = nums[0];
            int sumEndHere = nums[0];
            for(int i = 1;i < nums.Length; i++)
            {
                if(sumEndHere + nums[i] > nums[i])
                {
                    sumEndHere = sumEndHere + nums[i];
                }else
                {
                    sumEndHere = nums[i];
                }
                if(sumEndHere > maxSum)
                    maxSum =  sumEndHere ;
            }
            return maxSum;
        }
        //public int MaxSubArray(int[] nums)
        //{
        //    if (nums == null || nums.Length == 0) return 0;
        //    int maxSum = nums[0];
        //    int sumEndHere = nums[0];
        //    for (int i = 1; i < nums.Length; i++)
        //    {
        //        sumEndHere = Math.Max(nums[i], sumEndHere + nums[i]);
        //        maxSum = Math.Max(maxSum, sumEndHere);
        //    }
        //    return maxSum;
        //}
    }
}
